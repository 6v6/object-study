# Ch 10 상속과 코드 재사용

> 코드 재사용이 용이한 객체지향 프로그래밍의 기법중 '상속'에 대해 살펴보자!

## 01 상속과 중복 코드
### DRY 원칙
* 중복 코드의 문제점
  1. 변경을 방해 
  2. 코드를 수정하는 공수가 많이 필요함
* 중복 여부를 판단하는 기준은? => **변경**
  * 요구사항이 변경 됐을 때, 두 코드를 함께 수정해야 한다 => 이 코드는 **중복**이다.
* **DRY 법칙**
  * Don't Repeat Yourself의 줄임말 => **동일한 지식을 중복하지 말라**
  * 한번, 단 한번(Once and Only One) 원칙
  * 단일 지점 제어(Single-Point Control) 원칙

### 중복과 변경
* 상속은 **결합도**를 높임
  1. 상속을 이용한 코드 재사용은 부모 클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다. 
  2. 자식 클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가져야 한다.
* 중복 코드는 새로운 중복코드를 부른다

#### (상속으로) 강하게 결합된 Phone과 NightlyDiscountPhone
* 배경
  * 중복 코드를 줄이기 위해 Phone과 NightlyDiscountPhone를 상속으로 설계
* 문제 사항
  * **중복 발생**: 세금을 부과하는 정책이 추가되었을 때, 두 클래스르 모두 수정함
    * 중복을 제거하기위해 상속을 사용했으나, 새로운 로직을 추가하기 위해 중복 코드가 생겨남
  * **취약한 기반 클래스 문제** 발생: 상속관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상 발생

~~~ java
  public class Phone {
      private double taxRate; 
      
      public Phone(Money amount, Duration seconds, double taxRate) {
        ...
        this.taxTate = taxRate; 
      }

      public calculateFee() {
          ...
          return result.plus(result.times(taxRate));
      }

      public double getTaxRate() {
          return this.taxRate;
      }
  }
  ~~~

~~~  java
    public class NightlyDiscountPhone extends PHone {
      public NightlyDiscountPhone(Money nightlyAmount, Money regularAmount, Duration seconds, double taxRate) {
          super(regularAmount, seconds, taxRate);
          ...
      }

      @Override
      public Money calculateFee() {
          ...
          return result.minus(nightlyFee.plus(nightlyFee.times(getTaxRate()));
      }
  }
  ~~~

#### 취약한 기반 클래스 문제
> 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상

* 캡슐화를 약화시키고 결합도를 높임
  * 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킴

#### 불필요한 인터페이스 상속 문제 (과거 자바 예시)
> 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다

**1. Stack의 규칙에 맞지 않는 vector의 퍼블릭 인터페이스도 함께 상속받아 문제 발생**
* Vector를 재사용하하여 Stack을 Vector의 자식 클래스로 구현함
* Vector는 임의의 위치(index)에서 요소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공
* Stack은 맨 마지막 위치 에서만 요소를 추가하거나 제거할 수 있는 push, pop 오퍼레이션을 제공

~~~ java
Stack<String> stack = new Stack<>();
stack.push("1st");
stack.push("2nd");
stack.push("3rd");

stack.add(0, "4th");

assertEquals("4th", stack.pop()); // 에러!
~~~
**2. Hash와 Properties** 
* Properties가 hash의 퍼블릭 인터페이스를 이용하면 String이 아니여도 추가 가능함

### 메서드 오버라이딩의 오작용 문제
* 자식 클래스에서 메서드를 오버라이딩할 때, 부모 클래스의 다른 메서드에서 오버라이딩 하는 메서드를 호출하는지 파악해야 한다.
* 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

### 부모 클래스와 자식 클래스 동시 수정 문제
* 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

## 03 Phone 다시 살펴보기
### 추상화에 의존하자
* 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만드는 것 
* 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 함

### 중복 제거를 위한 상속 도입 -> 1 차이를 메서드로 추출하라
* 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 
* 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
* 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 
* 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

### 중복 제거를 위한 상속 도입 -> 2 중복 코드를 부모 클래스로 올려라
* 부모 클래스를 추가하자. 
* 목표는 모든 클래스들이 추상화에 의존하도록 만드는 것이기 때문에 이 클래스는 추상 클래스로 구현하는 것이 적합할 것이다. 
* 모든 하위 클래스가 이 행동을 할 수 있게 만들려면 여러 개의 중복 코드를 양산하거나 이 행동을 상위 클래스로 올리는 수밖에 없다.

### 추상화가 핵심이다
* 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가지게 된다.
* 단일 책임 원칙 준수
  * AbstractPhone - 전체 통화 목록의 계산 방법이 변경되었을 때
  * Phone - 일반 요금제의 통화 한 건을 계산하는 방식이 변경되었을 때
  * NightlyDiscountPhone - 심야 할인 요금제의 통화 한 건을 계산하는 방식이 변경되었을 때
* 의존성 역전 원칙 준수
  * 클래스들이 추상화에 의존하여 자식 클래스가 부모 클래스에 의존함
* 개방 폐쇄 원칙 준수
  * 새로운 요금제를 추가하면, 새로운 클래스를 추가한 후 메서드만 오버라이딩 하면 됨

## 04차이에 의한 프로그래밍
* 코드를 재사용하기 위해 맹목적으로 상속을 사용하는 것이 위험하다
* 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다.
* 정말로 필요한 경우에만 상속을 사용하라